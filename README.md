# junor-challenge
Тестовое задание

![Game result](task_png/game_result.png)

## About
Тестовое задание “Уголки” разбито на на уровни сложности. Каждый уровень добавляет некоторый функционал в игру. Все уровни кроме первого опциональны и просто добавляют тебе бонусов. 
Игру необходимо реализовать на движке Godot (https://godotengine.org/) последней стабильной версии (3.3).

## Отправка решения
Нажми на кнопку `Use this template` и создай приватный репозиторий github.
![task_btn](task_png/template_btn.png)
Пригласи в него `@jkb0o` и `@sdshorin`.
Создай проект в директории `game`, предварительно удалив оттуда `README.md`.
Папку .import нужно добавить в .gitignore! Понятная, детальная и неперегруженная история коммитов - большой плюс.


Тебе наверняка пригодится внимательно прочитать [туториалы](http://docs.godotengine.org/en/stable/), особенно рекомендую разделы [Step by Step](http://docs.godotengine.org/en/stable/getting_started/step_by_step/index.html) и [2D](http://docs.godotengine.org/en/stable/tutorials/2d/index.html).

Все необходимые картинки лежат в gfx.

## Правила игры.
После расстановки фигур на шахматной доске каждый игрок ходит по очереди. Во время хода он может переместить одну фигуру. Побеждает игрок который расставит все свои фигуры на место фигур противника. 
Расстановка фигур в начале игры:

![example_1](task_png/example_1.jpg)


## Возможные ходы:
Игрок может подвинуть фигуру на свободное место по горизонтали/вертикали/диагонали
Можно Пешками перепрыгивать через свои и чужие Пешки. Можно перепрыгивать за один ход несколько раз подряд.
- Например, Пешка g2 может перепрыгнуть несколько Пешек и оказаться на а8!
			`1. g2–e2–е4–с4–с6–а6–а8.`
- Чёрная Пешка b7, в свою очередь, допрыгнет до поля h1.
			`1. ... b7–b5–b3–d3–f3–h3–h1`

![example_2](task_png/example_2.jpg)

- Перепрыгивать можно только через ОДНУ Пешку. Например, Белая Пешка h2 не может сразу перелететь через cтоящие рядом g2 и f2. Можно несколько раз через одну Пешку за один ход, но не разом через несколько Пешек, стоящих рядом!


## Level 1. Core

При запуске игры отображается поле с расставленными фигурами.
В качестве клеток используется `white.png`. Для черных клеток она дополнительно окрашивается в `f9b067`.
Шашки - `checker_black.png` и `checker_white.png`

В интерфейсе отображается чей сейчас ход (черных/белых) и номер текущего хода.

При клике на свою фигуру она считается выбранной(поверх накладывается ободка `selected.png`). На поле стрелочками отображаются возможные ходы для этой фигуры. При клике на возможную позицию, фигура перемещается туда, и показываются возможные ходы относительно ее нового расположения. При повторном клике на выбранную фигуру она больше не считается выбранной, если она переместилась - ход заканчивается. Так же в стороне от игрового поля есть кнопка "Закончить ход".

При клике на свою фигуру A, когда выбрана фигура B - фигура B возвращается на позицию начала хода, после чего выбранной считается фигура A.

Когда все фигуры какого-то игрока заняли позицию оппонента, отображается экран Победителя - там указано кто выиграл (белые/черные) и кнопка “Начать заново”.


## Level 2. Animations
- Шашки должны перемещаться не мгновенно, а с анимацией.

## Level 3. Algorithms
- Нужно создать бота, который будет играть за противника. Достаточно, чтобы этот бот двигал шашки куда-то в нужном направлении(Достаточно простой эвристики, просчитывать варианты не нужно). В редких случаях бот может глючить.

## level 4. Master
- Бот должен быть умным! Он должен всегда доводить свои шашки до цели. Рекомендуется использовать эвристику и пытаться просчитывать игру на несколько ходов вперед. Или использовать самописные алгоритмы.




## Возможная реализация
### Это только возможный пример архитектуры игры, если у вас есть свои идеи - смело их реализуйте!

![diagram](task_png/diagram.png)


## Советы
- Сцену можно генерировать в первый кадр игры.
- У Godot есть куча возможностей - по возможности используйте их. Например, обрабатывать каждое движение мышки вручную можно только если это _действительно_ вам надо. То же относится и к ручным вызовам `_draw()`.
- Если нужно передать команду в модуль ниже по схеме - рекомендуется использовать функции или методы.
- Если нужно передать команду вверх по схеме - рекомендуется использовать сигналы. Например, `emit_signal("check_selected", self, ...)` или `emit_signal("step_completed")`.
- Все сигналы лучше коннектить через код. `node.connect("pressed", self, "start_game")`
- Просмотром документации проект не испортишь.
- Если появятся вопросы формата "есть два варианта реализации, какой выбрать" - пиши)

